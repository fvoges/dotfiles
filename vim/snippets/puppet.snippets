# vim: nofoldenable foldmethod=manual
snippet #!
	#! /usr/bin/env puppet

snippet '
	'${1:non interpreted string}'${2}
snippet "
	"${1:interpreted string}"${2}
snippet $
	${${1:variable}}${2}
snippet :
	'${1:title}':${2}
snippet =>
	${1:attribute} => '${2:value}',
	${3}
snippet +>
	${1:attribute} +> ${2:append_value},
	${3}
snippet ->
	${1:Type}['${2:title}'] -> ${3:Type}['${3:title}']
	${4}
snippet <-
	${1:Type}['${2:title}'] <- ${3:Type}['${3:title}']
	${4}
snippet ~>
	${1:Type}['${2:title}'] ~> ${3:Type}['${3:title}']
	${4}
snippet <~
	${1:Type}['${2:title}'] <~ ${3:Type}['${3:title}']
	${4}
snippet if
	if (${1:conditional}) {
	  ${2:# statements}
	}${3}
snippet else
	if (${1:conditional}) {
	  ${2:# statements}
	} else {
		${3:# default}
	}${4}
snippet elsif
	if (${1:conditional}) {
	  ${2:# statements}
	} elsif (${3:conditional}) {
		${4:# statements}
	} else {
		${5:# default}
	}${6}
snippet case
	case ${1:$operatingsystem} {
		${2:"centos", "redhat"}: {
			${3:# statements about $2}
		}
		"${4:default}": {
			${5:# statements about $4}
		}
	}${6}
snippet ?
	$${1:variable} ? {
		'${2}'  => '${3}',
		default => '${4}',
	}${5}
snippet cron
	cron {
		'${1:name}':
		  command => '${2:command}',
			hour    => '${3:hour}',
			minute  => '${4:minute}',
			day     => '${5:day}',
	}${6}
snippet File
	File {
	  owner => '${1:root}',
	  group => '${2:$1}',
	  mode  => '${3:0644}',
	}${4}
snippet file
	file {
	  '${1:/path/to/file}':
		  ensure  => '${3:directory, file, link, absent}',
	    source  => "puppet:///modules/${module_name}/${2:$1}",
			owner   => '${4:root}',
			group   => '${5:root}',
			mode    => '${6:0644}',
			recurse => '${7:false}',
	}${8}
snippet Exec
	Exec {
		path => '${1:/bin:/sbin:/usr/bin:/usr/sbin}',
	}${2}
snippet exec
	exec {
		'${1:/usr/bin/}':
		  command     => '${2}',
			refreshonly => true,
	}${3}
snippet package
	package {
		'${1:package}':
		  ensure => ${2:present, latest, absent, purge},
	}
snippet user
	user {
		'${1:username}':
		  ensure     => ${2:present, absent},
			home       => '${3:/home/$1}',
			uid        => '${4:333}',
			gid        => '${5:$4}',
			comment    => '${6:$1 account}',
			password   => '!!',
			shell      => '${7:/bin/bash, /bin/false, /sbin/nologin, /bin/zsh, /bin/tcsh}',
	}${8}
snippet define
	# Define: ${1:mydefinedtype}
	#
	#   ${2:defined type description goes here.}
	#
	# == Parameters
	#
	# == Actions
	#
	# == Requires
	#
	# == Example
	#
	define $1($3) {
	  ${4:# statements}
	}
	# EOF
snippet define::add Config Chunk
	# This define allows to add configuration fragments for $1
	#
	# == Parameters
	# [*content*]
	#   Configuration chunk to be added. Normally used with template().
	# [*order*]
	#   Order precedence of the chunk within the config file. The default (global) template uses order=10. Default: 15
	# == Requires
	#   Class['concat::setup']
	#
	#  Expects $fv_$1::params::config_file to be defined in $fv_$1::params
	# == Example
	#
	#  class someclass {
	#    fv_$1::config::add {'myextrachunk':
	#      content => template("${module_name}/myconfigchunk.erb"),
	#    }
	#  }
	define fv_${1:parentclass}::config::add($content='', $order=15) {
	  class { 'fv_$1::params': }
	  if $content == '' {
	    $body = $name
	  } else {
	    $body = $content
	  }

	  concat::fragment{"${fv_$1::config_file}_fragment_$name":
	    target  => $fv_$1::config_file,
	    content => $body,
	    order   => $order,
	  }
	}

	# ex: set et sw=2 ts=2 ft=puppet:
snippet class
	# Class: fv_${1:myclass}
	#
	# ${2:class description goes here.}
	#
	# == Parameters
	# [*enabled*]
	#   Enable $1's module and its services (default: 'true').
	# [*ensure*]
	#   Package's ensure attribute (default: 'installed').
	# == Examples
	#
	# ${3:Class' use example goes here.}
	#
	class fv_$1 (
		$enabled = hiera('$1_enabled'),
		$ensure = hiera('$1_ensure')
	) {
		anchor { 'fv_$1::begin': }~>
		class { 'fv_$1::package': }~>
		class { 'fv_$1::config': }~>
		class { 'fv_$1::service': }~>
		anchor { 'fv_$1::end': }
	}
	# ex: set et sw=2 ts=2 ft=pupet:
snippet class::
	# Class: fv_${1:parentclass}::${2:myclass}
	#
	# ${3:class description goes here.}
	#
	# == Parameters
	#
	# == Actions
	#
	# == Requires
	#
	# == Examples
	#
	class fv_$1::$2 inherits fv_$1 {
		${3:# statements}
	}
snippet class::config File
	# Class: fv_$1::config
	#
	# This class sets up configuration files for module $1.
	#
	# *Note:* This class should not be used externally.
	#
	# == Requires
	#   This requires $fv_$1::config_file to be defined.
	#
	class fv_${1:parentclass}::config {

		file { $fv_$1::config_file:
			ensure => ${2:file}
	    owner  => '${3:root}',
	    group  => '${4:$3}',
	    mode   => '${5:0444}',
	    source => "puppet:///modules/${module_name}/${6:configfile}",
	  }
	}
	# ex: set et sw=2 ts=2 ft=puppet:
snippet class::config Template
	# Class: fv_$1::config
	#
	# This class sets up configuration files for module $1.
	#
	# *Note:* This class should not be used externally.
	#
	# == Requires
	#   This requires $fv_$1::config_file to be defined.
	#
	class fv_${1:parentclass}::config {

		file { $fv_$1::config_file:
			ensure  => ${2:file}
	    owner   => '${3:root}',
	    group   => '${4:$3}',
	    mode    => '${5:0444}',
	    content => template("${module_name}/${6:configfile}.erb",
	  }
	}
	# ex: set et sw=2 ts=2 ft=puppet:
snippet class::config Concat Module
	# Class: fv_$1::config
	#
	# This class sets up configuration files for module $1.
	#
	# *Note:* This class should not be used externally.
	#
	# == Requires
	#   This requires $fv_$1::config_file to be defined.
	#
	#   Depends on Class['concat::setup']
	#
	class fv_${1:parentclass}::config {
		Class { require => Class['concat::setup'], }

	  concat { $fv_$1::config_file:
	    owner => '${2:root}',
	    group => '${3:$3}',
	    mode  => '${4:0444}',
	  }

	  concat::fragment{"${fv_$1::config_file}_global":
	    target  => $fv_$1::config_file,
	    content => template("${module_name}/${5:chunk_template}${5:template}.erb"),
	    order   => 10,
	  }
	}
	# ex: set et sw=2 ts=2 ft=puppet:
snippet class::package
	# This class will install the packages for $1.
	#
	# *Note*: This class should not be used externally.
	class fv_${1:parentclass}::package ($ensure = $fv_$1::ensure) {
	  package { '${2:package_name}' : ensure => $ensure }

	}

	# ex: set ts=2 et sw=2 filetype=puppet:
snippet class::params
	# This class provides parameters for all the other classes in the
	# module $1.
	class fv_${1:parentclass}::params {

		$$1_ensure = '${2:installed}'
	  $$1_enabled = '${3:true}'

		${4:# Extra params here...}
	}
	# ex: set ts=2 et sw=2 ft=puppet:
snippet class::service
	# This class manages services for $1.
	class fv_${1:parentclass}::service ($enabled = $fv_$1::enabled){
	  if $enabled == 'true' {
	    $ensure = 'running'
	  } else {
	    $ensure = 'stopped'
	  }

	  service { '${2:servicename}' :
	    ensure     => $ensure,
	    enable     => $enabled,
	    hasstatus  => true,
	    hasrestart => true,
	  }
	}
	# ex: set ts=2 et sw=2 ft=puppet:
